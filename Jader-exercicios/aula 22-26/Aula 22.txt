Ex1 aula 22
raiz
├── A
│   ├── BACATES$ (sufixo 1)
│   └── CATES$ (sufixo 3)
├── BACATES$ (sufixo 2)
├── CATES$ (sufixo 4)
├── TES$ (sufixo 6)
├── ES$ (sufixo 7)
└── S$ (sufixo 8)

Suffix Array: [8, 1, 3, 2, 4, 6, 7, 5]

------------------------------
Ex2 aula 22
O ponteiro ativo é um mecanismo crucial no algoritmo de Ukkonen que permite a construção 
online da árvore de sufixos em tempo linear O(n). Ele consiste em três componentes:

Nó ativo: O nó atual onde a inserção está ocorrendo

Aresta ativa: A aresta sendo processada

Comprimento ativo: A posição dentro da aresta
O ponteiro ativo evita a necessidade de recomeçar do início a cada novo caractere adicionado.
Ele "lembra" a posição onde o próximo sufixo deve ser inserido, permitindo que o algoritmo 
processe cada caractere em tempo constante amortizado, tornando possível a construção incremental
à medida que a string é lida.

----------------------------------
Ex3 Aula 22
Se termina no meio de uma aresta: 
Significa que o padrão P ocorre como prefixo de vários sufixos da string, 
mas não é um sufixo completo por si só. Todas as ocorrências de P são contínuas no texto.

Se termina exatamente em um nó interno: Significa que P é um sufixo completo de 
algum prefixo da string original e também é prefixo de múltiplos outros sufixos. 
O nó interno representa o ponto onde vários sufixos divergem.

----------------------------
Ex4 aula 22
Árvore de Sufixo:

Vantagens: Busca extremamente rápida (O(m) para padrão de tamanho m), construção online possível

Desvantagens: Alto consumo de memória, complexidade de implementação

Suffix Array:

Vantagens: Uso eficiente de memória (4-8 bytes por caractere), implementação mais simples, 
melhor para armazenamento em disco

Desvantagens: Busca mais lenta (O(m log n) com busca binária), construção offline apenas

------------------------------
Ex5 aula22
S1 = "BBBAAAS" → BWT = "AABABBS"

Caracteres similares agrupados: "AAA", "BBB", "S"

Mais compressível: A BWT cria execuções longas de caracteres idênticos

S2 = "BABABAS" → BWT = "ABBBAAAS"

Padrão alternado na string original resulta em mistura na BWT

Menos compressível: Caracteres alternados criam menos execuções longas

A BWT do S1 é mais fácil de comprimir porque transforma a string em execuções 
mais longas de caracteres repetidos, que são altamente compressíveis por algoritmos como RLE (Run-Length Encoding).

-----------------------------
ex6 - 22

SA-IS (Suffix Array Induced Sorting):

Constrói suffix arrays em tempo linear O(n)

Baseado em classificação indutiva e divisão de sufixos em tipos

Mais eficiente em memória que árvores de sufixo

Adequado para aplicações que precisam apenas do array

Ukkonen:

Constrói árvores de sufixo em tempo linear O(n)

Algoritmo online (pode processar stream de dados)

Consome mais memória que SA-IS

Fornece estrutura mais rica para operações complexas

----------------------------
ex7 - 22

O Bowtie2 usa o FM-Index (combinação de BWT + Suffix Array + estrutras auxiliares) para:

Backtracking eficiente: Usa a propriedade LF-mapping para navegar rapidamente

Busca exata: Encontra todas as ocorrências de leituras curtas no genoma

Baixo uso de memória: Comprime o genoma de referência mantendo busca rápida

A eficiência vem da propriedade de last-first que permite reconstruir o texto backward com acesso constante às ocorrências.

--------------------------------------------

ex 8 - 22
Não, Huffman não é ideal para comprimir a saída da BWT porque:

A BWT já organiza os dados em execuções longas de caracteres similares

RLE (Run-Length Encoding) é muito mais eficiente para dados BWT

Move-to-Front + Huffman pode ser usado, mas Huffman sozinho não explora bem as características da BWT

A BWT é pré-processamento para outros algoritmos de compressão (como em bzip2), não o método final de compressão.